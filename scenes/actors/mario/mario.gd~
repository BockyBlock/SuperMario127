extends KinematicBody2D

class_name Character

signal state_changed

onready var states_node = $States
onready var nozzles_node = $Nozzles
onready var powerups_node = $Powerups
onready var animated_sprite = $Sprite
onready var anim_player = $AnimationPlayer

onready var spotlight = $Spotlight

# Cutout
export var cutout_death : StreamTexture
export var cutout_circle : StreamTexture
export var cutout_shine : StreamTexture

# Basic Physics
export var initial_position := Vector2(0, 0)
export var velocity := Vector2(0, 0)
var last_velocity := Vector2(0, 0)

export var gravity_scale = 1
export var facing_direction = 1
export var move_direction = 0
export var last_move_direction = 0

export var move_speed = 216.0
export var acceleration = 7.5
export var deceleration = 15.0
export var aerial_acceleration = 7.5
export var friction = 10.5
export var aerial_friction = 1.15

# Sounds
var sound_player
var footstep_interval = 0

# Extra
export var is_wj_chained = false
export var real_friction = 0
export var current_jump = 0
export var jump_animation = 0
export var direction_on_stick = 1
export var rotating = true
export var spawn_pos = Vector2(0, 0)
export var gravity : float

export var disable_movement = false
export var disable_turning = false
export var disable_friction = false
export var disable_animation = false

export var attacking = false
export var big_attack = false
export var invincible = false
export var heavy = false

export var player_id = 0

# States
var state = null
var last_state = null
var switching_state = false
export var controllable = true
export var invulnerable = false
export var invulnerable_frames = 0
export var movable = true
export var dead = false
export var stomping = false
export var dive_cooldown = 0

export var health := 8
export var health_shards := 0
var nozzle = null
var using_turbo = false
var turbo_nerf = false
var fuel := 100.0
var stamina := 100.0
var nozzles_list_index := 0
var powerup = null
var rainbow_stored = false
var next_flash = 0.0
var frames_until_flash = 3
var metal_voice = false

# Collision vars
var collision_down
var collision_up
var collision_left
var collision_right
var collided_last_frame = false
var using_dive_collision = false

export var snap := Vector2(0, 32)

export(Array, NodePath) var collision_exceptions = []

# Character vars
export var character := 0

export var mario_frames : SpriteFrames
export var luigi_frames : SpriteFrames

export var mario_alt_frames : SpriteFrames
export var luigi_alt_frames : SpriteFrames

export var mario_collision : RectangleShape2D
export var mario_collision_offset : Vector2
export var mario_dive_collision : RectangleShape2D
export var mario_dive_collision_offset : Vector2

export var luigi_collision : RectangleShape2D
export var luigi_collision_offset : Vector2
export var luigi_dive_collision : RectangleShape2D
export var luigi_dive_collision_offset : Vector2

export var luigi_accel : float
export var luigi_fric : float
export var luigi_speed : float

# Inputs 
# First parameter is "pressed",
# second parameter is "just_pressed", 
# and third parameter is the input name.
export var inputs = [
	[false, false, "left"], # Index 0
	[false, false, "right"], # Index 1
	[false, false, "jump"], # Index 2
	[false, false, "dive"], # Index 3
	[false, false, "spin"], # Index 4
	[false, false, "gp"], # Index 5
	[false, false, "gpcancel"], # Index 6
	[false, false, "fludd"], # Index 7
	[false, false, "nozzles"], # Index 8
	[false, false, "crouch"] # Index 9
]

enum input_names {left, right, jump, dive, spin, gp, gpcancel, fludd, nozzles, crouch}

export var controlled_locally = true

export var rotating_jump = false

#onready var global_vars_node = get_node("../GlobalVars")
#onready var level_settings_node = get_node("../LevelSettings")
onready var collision_shape = $Collision
onready var collision_raycast = $GroundCollision
onready var dive_collision_shape = $CollisionDive
onready var ground_check = $GroundCheck
onready var slope_stop_check = $SlopeStopCheck
onready var ground_check_dive = $GroundCheckDive
onready var left_check = $LeftCheck
onready var right_check = $RightCheck
onready var left_collision = $LeftCollision
onready var right_collision = $RightCollision
onready var ground_collision_dive = $GroundCollisionDive
onready var player_collision = $PlayerCollision
onready var player_collision_shape = $PlayerCollision/CollisionShape2D
onready var sprite = $Sprite
onready var fludd_sprite = $Sprite/Fludd
onready var water_sprite = $Sprite/Water
onready var water_sprite_2 = $Sprite/Water2
onready var fludd_sound = $FluddSound
onready var fludd_charge_sound = $FluddChargeSound
onready var nozzle_switch_sound = $NozzleSwitchSound
onready var particles = $Particles2D
onready var slide_particles = $SlideParticles
onready var gp_particles1 = $GPParticles1
onready var gp_particles2 = $GPParticles2
onready var rainbow_particles = $RainbowSparkles
onready var metal_particles = $MetalSparkles
onready var platform_detector = $PlatformDetector
onready var bottom_pos = $BottomPos
onready var death_sprite = $DeathSprite
onready var death_fludd_sprite = $DeathSprite/Fludd
onready var collected_shine = $CollectedShine # used for the shine dance animation, can be edited to reflect different shine colours or sprites or something
onready var raycasts = [ground_check, ground_check_dive, left_check, right_check, slope_stop_check]
export var bottom_pos_offset : Vector2
export var bottom_pos_dive_offset : Vector2

var level_bounds = Rect2(0, 0, 80, 30)
var number_of_players = 2

var next_position : Vector2
var sync_interpolation_speed = 20
export var rotation_interpolation_speed = 15

#rpc_unreliable("update_inputs", 
#left, left_just_pressed,
#right, right_just_pressed,
#jump, jump_just_pressed,
#dive, dive_just_pressed,
#spin, spin_just_pressed
#)

puppet func sync(pos, vel, sprite_frame, sprite_animation, sprite_rotation, is_attacking, is_big_attacking, is_heavy, is_dead, is_controllable): # Ok slave
	next_position = pos
	velocity = vel
	sprite.animation = sprite_animation
	sprite.frame = sprite_frame
	sprite.rotation_degrees = sprite_rotation
	attacking = is_attacking
	big_attack = is_big_attacking
	heavy = is_heavy
	dead = is_dead
	controllable = is_controllable

func is_character():
	return true

func exploded(explosion_pos : Vector2):
	if !invincible:
		damage_with_knockback(explosion_pos, 2)

func steely_hit(steely_pos : Vector2):
	if !invincible:
		damage_with_knockback(steely_pos, 2)

func damage_with_knockback(hit_pos : Vector2, amount : int = 1, cause : String = "hit", frames : int = 180):
	if !invulnerable:
		if powerup != null and amount > 0:
			if powerup.get_name() == "VanishPowerup":
				return
		var direction = 1
		if (global_position - hit_pos).normalized().x < 0:
			direction = -1
		velocity.x = direction * 235
		velocity.y = -225
		set_state_by_name("KnockbackState", 0)
		damage(amount, cause, frames)

# warning-ignore: unused_argument
func load_in(level_data : LevelData, level_area : LevelArea):
	level_bounds = level_area.settings.bounds
	for exception in collision_exceptions:
		add_collision_exception_with(get_node(exception))
	var _connect = player_collision.connect("body_entered", self, "player_hit")
		
	if character == 0:
		var sound_scene = MiscCache.mario_sounds
		sound_player = sound_scene.instance()
		add_child(sound_player)
		if PlayerSettings.player1_character != PlayerSettings.player2_character or player_id == 0:
			sprite.frames = mario_frames
			death_sprite.frames = mario_frames
		else:
			sprite.frames = mario_alt_frames
			death_sprite.frames = mario_alt_frames
		#collision_shape.position = mario_collision_offset
		#collision_shape.shape = mario_collision
		#player_collision_shape.position = mario_collision_offset
		#player_collision_shape.shape = mario_collision
		#ground_collision_dive.shape = mario_dive_collision
		#ground_collision_dive.position = mario_dive_collision_offset
		real_friction = friction
	else:
		var sound_scene = MiscCache.luigi_sounds
		sound_player = sound_scene.instance()
		add_child(sound_player)
		if PlayerSettings.player1_character != PlayerSettings.player2_character or player_id == 0:
			sprite.frames = luigi_frames
			death_sprite.frames = luigi_frames
		else:
			sprite.frames = luigi_alt_frames
			death_sprite.frames = luigi_alt_frames
		#collision_shape.position = luigi_collision_offset
		#collision_shape.shape = luigi_collision
		#player_collision_shape.position = luigi_collision_offset
		#player_collision_shape.shape = luigi_collision
		#ground_collision_dive.shape = luigi_dive_collision
		#ground_collision_dive.position = luigi_dive_collision_offset
		move_speed = luigi_speed
		acceleration = luigi_accel
		friction = luigi_fric
		real_friction = luigi_fric
	collision_shape.disabled = false
	collision_raycast.disabled = false
	left_collision.disabled = false
	right_collision.disabled = false
	gravity = level_area.settings.gravity
	
	# reset some stuff that can be changed by accident when using the editor
	sprite.playing = true
	collected_shine.visible = false
	collected_shine.get_node("ShineParticles").emitting = false

var prev_is_grounded = false
var recalculate_grounded = false
func is_grounded():
	if recalculate_grounded:
		var raycast_node = ground_check
		raycast_node.cast_to = Vector2(0, 26)
		if !ground_collision_dive.disabled:
			raycast_node = ground_check_dive
			raycast_node.cast_to = Vector2(0, 7.5)
		
		raycast_node.force_raycast_update()
		var new_is_grounded = raycast_node.is_colliding() and velocity.y >= 0
		if !new_is_grounded and prev_is_grounded and velocity.y > 0:
			velocity.y = 0
		
		prev_is_grounded = new_is_grounded
		
		#recalculate_grounded = false
	return prev_is_grounded

func is_ceiling():
	return test_move(self.transform, Vector2(0, -0.1)) and collided_last_frame

func is_walled():
	return (is_walled_left() or is_walled_right()) and collided_last_frame

func is_walled_left():
	return test_move(self.transform, Vector2(-0.5, 1)) and test_move(self.transform, Vector2(-0.5, -1)) and collided_last_frame

func is_walled_right():
	return test_move(self.transform, Vector2(0.5, 1)) and test_move(self.transform, Vector2(0.5, -1)) and collided_last_frame

func hide():
	visible = false
	velocity = Vector2(0, 0)
	position = initial_position

func show():
	visible = true

func set_state(new_state, delta: float):
	recalculate_grounded = true
	last_state = state
	state = null
	if last_state != null:
		last_state._stop(delta)
	if new_state != null:
		state = new_state
		new_state._start(delta)
	emit_signal("state_changed", new_state, last_state)

func get_state_node(name: String):
	if states_node.has_node(name):
		return states_node.get_node(name)
		
func get_powerup_node(name: String):
	if powerups_node.has_node(name):
		return powerups_node.get_node(name)

func set_powerup(powerup_node):
	if powerup != null:
		powerup._stop(0)
		powerup.remove_visuals()

	if powerup_node != null:
		powerup = powerup_node
		powerup_node._start(0)
		powerup_node.apply_visuals()
	else:
		powerup = null

func set_state_by_name(name: String, delta: float):
	if get_state_node(name) != null:
		set_state(get_state_node(name), delta)
		
func add_nozzle(new_nozzle):
	if !new_nozzle in CurrentLevelData.level_data.vars.nozzles_collected:
		CurrentLevelData.level_data.vars.nozzles_collected.append(new_nozzle)
		
func get_nozzle_node(name: String):
	if nozzles_node.has_node(name):
		return nozzles_node.get_node(name)
		
func set_nozzle(new_nozzle, change_index = true):
	fludd_sound.stop()
	fludd_charge_sound.stop()
	if nozzle != null:
		nozzle.activated = false
		nozzle.last_activated = false
	nozzle = get_nozzle_node(str(new_nozzle))
	water_sprite.animation = "in"
	water_sprite.frame = 6
	water_sprite.rotation_degrees = 0
	using_turbo = false
	turbo_nerf = false
	if change_index:
		nozzles_list_index = CurrentLevelData.level_data.vars.nozzles_collected.find(str(new_nozzle))
		
func player_hit(body):
	if body.name.begins_with("Character"):
		if !body.big_attack and !big_attack:
			if global_position.y + 8 < body.global_position.y:
				velocity.y = -230
				#body.stomped_sound_player.play() -Felt weird without animations
				if state != get_state_node("DiveState") and state != get_state_node("GroundPoundState") and state != get_state_node("GroundPoundStartState") and state != get_state_node("GroundPoundEndState"):
					set_state_by_name("BounceState", 0)
			elif global_position.y - 8 > body.global_position.y:
				velocity.y = 150
			elif global_position.x < body.global_position.x:
				if body.attacking == true and !attacking:
					velocity.x = -205
					velocity.y = -175
					body.velocity.x = 250
					set_state_by_name("KnockbackState", 0)
					sound_player.play_hit_sound()
				elif !attacking or (body.attacking and attacking):
					velocity.x = -250
					body.velocity.x = 250
			elif global_position.x > body.global_position.x:
				if body.attacking == true and !attacking:
					velocity.x = 205
					velocity.y = -175
					body.velocity.x = -250
					set_state_by_name("KnockbackState", 0)
					sound_player.play_hit_sound()
				elif !attacking or (body.attacking and attacking):
					velocity.x = 250
					body.velocity.x = -250
		elif !big_attack:
			if global_position.x < body.global_position.x:
				velocity.x = -205
				velocity.y = -175
				body.velocity.x = 250
				set_state_by_name("KnockbackState", 0)
				sound_player.play_hit_sound()
			else:
				velocity.x = 205
				velocity.y = -175
				body.velocity.x = -250
				set_state_by_name("KnockbackState", 0)
				sound_player.play_hit_sound()

func _process(delta: float):
	if state and state.name == "NoActionState":
		return
		
	if powerup != null:
		if powerup.time_left <= 2.5:
			frames_until_flash -= 1
			if frames_until_flash <= 0:
				frames_until_flash = 3
				powerup.toggle_visuals()

	if invulnerable_frames > 0:
		visible = !visible
	elif invulnerable_frames == 0:
		visible = true
	if next_position:
		position = position.linear_interpolate(next_position, delta * sync_interpolation_speed)

func damage(amount : int = 1, cause : String = "hit", frames : int = 180):
	if !dead:
		if invincible:
			frames = 4
		else:
			health -= amount
		invulnerable = true if frames != 0 else false
		invulnerable_frames = frames
		if health <= 0:
			health = 0 # Fix -1 bug
			sound_player.play_last_hit_sound()
			kill(cause)
		else:
			sound_player.play_hit_sound()
			
func heal(shards : int = 1):
	if !dead and health != 8:
		health_shards += shards
		# warning-ignore: narrowing_conversion
		health = clamp(int(health + floor(health_shards / 5.0)), 0, 8)
		health_shards = health_shards % 5
		if health == 8:
			health_shards = 0


func get_weight():
	return 2 if metal_voice else 1

func _physics_process(delta: float):
	update_inputs()
	
	if state and state.name == "NoActionState":
		return
	
	recalculate_grounded = true
	
	bottom_pos.position = bottom_pos_offset
	if !ground_collision_dive.disabled:
		bottom_pos.position = bottom_pos_dive_offset
	var is_in_platform = false
	var platform_collision_enabled = false
	for body in platform_detector.get_overlapping_areas():
		if body.has_method("is_platform_area"):
			if body.is_platform_area():
				is_in_platform = true
			if body.get_parent().can_collide_with(self):
				platform_collision_enabled = true
	set_collision_mask_bit(4, platform_collision_enabled)
	for raycast in raycasts:
		raycast.set_collision_mask_bit(4, platform_collision_enabled)
	
	if invulnerable_frames > 0:
		invulnerable_frames -= 1
		invulnerable = true
	elif invulnerable_frames == 0:
		invulnerable = false
	
	# Gravity
	velocity.y = lerp(velocity.y, (gravity * Vector2(0, gravity_scale) * 240).y, delta / 2)

	if state != null:
		disable_movement = state.disable_movement
		disable_turning = state.disable_turning
		disable_animation = state.disable_animation
		disable_friction = state.disable_friction
	else:
		disable_movement = false
		disable_turning = false
		disable_animation = false
		disable_friction = false
	# Movement
	if using_turbo and nozzle.boosted:
		move_direction = facing_direction # Can't turn and forced to move forward
	else:
		move_direction = 0
		if inputs[0][0] and !inputs[1][0] and disable_movement == false:
			move_direction = -1
		elif inputs[1][0] and !inputs[0][0] and disable_movement == false:
			move_direction = 1
	
	if move_direction != 0:
		if is_grounded():
			if ((velocity.x > 0 and move_direction == -1) or (velocity.x < 0 and move_direction == 1)):
				velocity.x += deceleration * move_direction
			elif ((velocity.x < move_speed and move_direction == 1) or (velocity.x > -move_speed and move_direction == -1)):
				velocity.x += acceleration * move_direction
			elif ((velocity.x > move_speed and move_direction == 1) or (velocity.x < -move_speed and move_direction == -1)):
				velocity.x -= 3.5 * move_direction
			
			facing_direction = move_direction

			if !disable_animation and movable and controlled_locally:
				if !is_walled():
					if (abs(velocity.x) > move_speed):
						sprite.speed_scale = abs(velocity.x) / move_speed
					else:
						sprite.speed_scale = 1
					var animation_frame = sprite.frame
					if move_direction == 1:
						sprite.animation = "movingRight"
						if last_move_direction != move_direction:
							sprite.frame = animation_frame + 1
					else:
						sprite.animation = "movingLeft"
						if last_move_direction != move_direction:
							sprite.frame = animation_frame + 1
				else:
					if facing_direction == 1:
						sprite.animation = "idleRight"
					else:
						sprite.animation = "idleLeft"
					sprite.speed_scale = 0
				if footstep_interval <= 0 and sprite.speed_scale > 0:
					sound_player.play_footsteps()
					footstep_interval = clamp(0.8 - (sprite.speed_scale / 2.5), 0.1, 1)
				footstep_interval -= delta
		else:
			if ((velocity.x < move_speed and move_direction == 1) or (velocity.x > -move_speed and move_direction == -1)):
				velocity.x += aerial_acceleration * move_direction
			elif ((velocity.x > move_speed and move_direction == 1) or (velocity.x < -move_speed and move_direction == -1)):
				velocity.x -= 0.25 * move_direction
			if !disable_turning:
				facing_direction = move_direction
	elif !disable_friction:
		if (velocity.x > 0):
			if (velocity.x > 15):
				if (is_grounded()):
					velocity.x -= friction
				else:
					if abs(velocity.x) > move_speed:
						velocity.x -= aerial_friction*2
					else:
						velocity.x -= aerial_friction
			else:
				velocity.x = 0
		elif (velocity.x < 0):
			if (velocity.x < -15):
				if (is_grounded()):
					velocity.x += friction
				else:
					if abs(velocity.x) > move_speed:
						velocity.x += aerial_friction*2
					else:
						velocity.x += aerial_friction
			else:
				velocity.x = 0

		if !disable_animation and movable and controlled_locally:
			if is_grounded():
				if facing_direction == 1:
					sprite.animation = "idleRight"
				else:
					sprite.animation = "idleLeft"
				sprite.speed_scale = 1
	
	if movable and (state == null or !state.override_rotation) and (!is_instance_valid(nozzle) or !nozzle.override_rotation) and !rotating_jump and last_state != get_state_node("SlideState"):
		var sprite_rotation = 0
		var sprite_offset = Vector2()
		if is_grounded():
			var normal = ground_check.get_collision_normal()
			sprite_rotation = (atan2(normal.y, normal.x) + (PI/2)) / 2
			sprite_offset = Vector2(rad2deg(sprite_rotation) / 10, -abs(rad2deg(sprite_rotation) / 10))
			
			# Translate velocity X to Y
			if normal.y != 0: # Avoid division by zero (what)
				velocity.y += (velocity.x * normal.x / normal.y) * -1
				if velocity.y < 0: # upwards velocity, don't allow that
					velocity.y = 0
			
			# this is required to keep mario from falling off slopes
			#velocity.y += (abs(sprite_rotation) + 1) * 100
			
			#if !abs(normal.x) > 0.2:
			#	velocity.y = 0

		sprite.position = sprite.position.linear_interpolate(sprite_offset, delta * rotation_interpolation_speed)
		sprite.rotation = lerp_angle(sprite.rotation, sprite_rotation, delta * rotation_interpolation_speed)
		sprite.rotation_degrees = wrapf(sprite.rotation_degrees, -180, 180)

	if PlayerSettings.other_player_id == -1 or PlayerSettings.my_player_index == player_id:
		for state_node in states_node.get_children():
			state_node.handle_update(delta)
			
		for nozzle_node in nozzles_node.get_children():
			nozzle_node.handle_update(delta)
		
		for powerup_node in powerups_node.get_children():
			powerup_node.handle_update(delta)

	if powerup != null:
		invincible = powerup.is_invincible
		powerup.time_left -= delta

		if powerup.time_left <= 0:
			powerup.time_left = 0
			set_powerup(null)
	else:
		invincible = false

	if state != null:
		if state.attack_tier > 1:
			big_attack = true
		else:
			big_attack = false

		if state.attack_tier > 0:
			attacking = true
		else:
			attacking = false
			
		if state.use_dive_collision and !using_dive_collision:
			using_dive_collision = true

			collision_shape.disabled = true
			collision_raycast.disabled = true
			dive_collision_shape.disabled = false
			ground_collision_dive.disabled = false
			left_collision.disabled = true
			right_collision.disabled = true
		if !state.use_dive_collision and using_dive_collision:
			using_dive_collision = false

			collision_shape.disabled = false
			collision_raycast.disabled = false
			dive_collision_shape.disabled = true
			ground_collision_dive.disabled = true
			left_collision.disabled = false
			right_collision.disabled = false
				
		if state.disable_snap:
			snap = Vector2()
		elif (left_check.is_colliding() or right_check.is_colliding()) and velocity.y > 0:
			var normal = ground_check.get_collision_normal()
			if normal.x == 0:
				snap = Vector2(0, 6)
			else:
				snap = Vector2(0, 12)
		else:
			snap = Vector2()
	else:
		attacking = false
		big_attack = false
		if (left_check.is_colliding() or right_check.is_colliding()) and velocity.y > 0:
			var normal = ground_check.get_collision_normal()
			if normal.x == 0:
				snap = Vector2(0, 6)
			else:
				snap = Vector2(0, 12)
		else:
			snap = Vector2()
	if is_in_platform:
		snap = Vector2()
			
	if inputs[8][1] and CurrentLevelData.level_data.vars.nozzles_collected.size() > 1:
		nozzles_list_index += 1
		if nozzles_list_index >= CurrentLevelData.level_data.vars.nozzles_collected.size():
			nozzles_list_index = 0
		
		var new_nozzle = str(CurrentLevelData.level_data.vars.nozzles_collected[nozzles_list_index])
		set_nozzle(new_nozzle, false)
		
		nozzle_switch_sound.play()
		print(CurrentLevelData.level_data.vars.nozzles_collected)
		
	if is_instance_valid(nozzle):
		fludd_sprite.visible = true
		water_sprite.visible = true
		if nozzle.get_name() == "HoverNozzle":
			water_sprite_2.visible = true
			water_sprite_2.flip_h = water_sprite.flip_h
			water_sprite_2.animation = water_sprite.animation
			water_sprite_2.frame = water_sprite_2.frame
		else:
			water_sprite_2.visible = false
		if nozzle.activated:
			attacking = true
		if character == 0:
			fludd_sprite.frames = nozzle.frames
			death_fludd_sprite.frames = fludd_sprite.frames
		else:
			fludd_sprite.frames = nozzle.frames_luigi
			death_fludd_sprite.frames = fludd_sprite.frames
		fludd_sprite.animation = sprite.animation
		fludd_sprite.frame = sprite.frame
		
		if character == 0:
			if sprite.animation in nozzle.animation_water_positions:
				water_sprite.position = nozzle.animation_water_positions[sprite.animation]
			else:
				if facing_direction == 1:
					water_sprite.position = nozzle.fallback_water_pos_right
				else:
					water_sprite.position = nozzle.fallback_water_pos_left
		else:
			if sprite.animation in nozzle.animation_water_positions_luigi:
				water_sprite.position = nozzle.animation_water_positions_luigi[sprite.animation]
			else:
				if facing_direction == 1:
					water_sprite.position = nozzle.fallback_water_pos_right_luigi
				else:
					water_sprite.position = nozzle.fallback_water_pos_left_luigi
					
		water_sprite_2.position = water_sprite.position - Vector2(-5 * facing_direction, 2)
	else:
		fludd_sprite.visible = false
		water_sprite.visible = false
		water_sprite_2.visible = false

	death_fludd_sprite.visible = fludd_sprite.visible

	# Move by velocity
	if movable:
		velocity = move_and_slide_with_snap(velocity, snap, Vector2.UP, true, 4, deg2rad(46))
		var slide_count = get_slide_count()
		collided_last_frame = slide_count > 0
	else:
		collided_last_frame = false

	# Boundaries
	if position.y > (level_bounds.end.y * 32) + 128:
		if PlayerSettings.other_player_id == -1 or PlayerSettings.my_player_index == player_id:
			kill("fall")
	if position.x < level_bounds.position.x * 32:
		position.x = level_bounds.position.x * 32
		velocity.x = 0
	if position.x > level_bounds.end.x * 32 -1:
		position.x = level_bounds.end.x * 32 -1
		velocity.x = 0
	last_velocity = velocity
	last_move_direction = move_direction
	
	if PlayerSettings.other_player_id != -1:
		if player_id == PlayerSettings.my_player_index and is_network_master():
			rpc_unreliable("sync", position, velocity, sprite.frame, sprite.animation, sprite.rotation_degrees, attacking, big_attack, heavy, dead, controllable)
	
func switch_areas(area_id, transition_time):
	scene_transitions.reload_scene(cutout_circle, cutout_circle, transition_time, area_id)
	
func kill(cause):
	if !dead:
		dead = true
		var reload = true
		var cutout_in = cutout_circle
		var cutout_out = cutout_circle
		var transition_time = 0.75
		if cause == "fall":
			controllable = false
			sound_player.play_fall_sound()
			if number_of_players == 1:
				cutout_in = cutout_death
				yield(get_tree().create_timer(1), "timeout")
			else:
				reload = false
		elif cause == "reload":
			transition_time = 0.4
		elif cause == "green_demon":
			sound_player.play_last_hit_sound()
			controllable = false
			movable = false
			cutout_in = cutout_death
			sprite.visible = false
			death_sprite.set_as_toplevel(true)
			death_sprite.global_position = sprite.global_position
			death_sprite.play_anim()
			position = Vector2(0, 100000000000000000)
			yield(get_tree().create_timer(0.55), "timeout")
			sound_player.play_death_sound()
			yield(get_tree().create_timer(0.75), "timeout")
		elif cause == "hit":
			controllable = false
			movable = false
			cutout_in = cutout_death
			sprite.visible = false
			death_sprite.set_as_toplevel(true)
			death_sprite.global_position = sprite.global_position
			death_sprite.play_anim()
			position = Vector2(0, 100000000000000000)
			yield(get_tree().create_timer(0.55), "timeout")
			sound_player.play_death_sound()
			yield(get_tree().create_timer(0.75), "timeout")
			if number_of_players != 1:
				reload = false
			
		if reload:
			scene_transitions.reload_scene(cutout_in, cutout_out, transition_time, 0, true)
		else:
			yield(get_tree().create_timer(3), "timeout")
			health = 8
			position = spawn_pos - Vector2(0, 16)
			dead = false
			movable = true
			sprite.visible = true
			death_sprite.visible = false
			controllable = true
			set_state_by_name("FallState", 0)

func exit():
	#if the mode switcher button is not invisible, we're in edit mode, switch back to that, but if we're in play mode then for now just reload the scene
	if !mode_switcher.get_node("ModeSwitcherButton").invisible:
		mode_switcher.get_node("ModeSwitcherButton").switch()
	else: 
		# warning-ignore: return_value_discarded
		get_tree().reload_current_scene()

func set_all_collision_masks(bit, value):
	set_collision_mask_bit(bit, value)
	$GroundCheck.set_collision_mask_bit(bit, value)
	$GroundCheckDive.set_collision_mask_bit(bit, value)
	$LeftCheck.set_collision_mask_bit(bit, value)
	$RightCheck.set_collision_mask_bit(bit, value)
	$SlopeStopCheck.set_collision_mask_bit(bit, value)

func get_input(input_id : int, is_just_pressed : bool) -> bool:
	return inputs[input_id][int(is_just_pressed)]

func update_inputs():
	if controlled_locally:
		if controllable and !FocusCheck.is_ui_focused:
			#var control_id = player_id seemingly unused variable, uncomment if needed
			for input in inputs:
				if Input.is_action_pressed(input[2]):
					input[0] = true
				else:
					input[0] = false
					
				if Input.is_action_just_pressed(input[2]):
					input[1] = true
				else:
					input[1] = false
		else:
			for input in inputs:
				input[0] = false
				input[1] = false

snippet test "Test Snippet" 


snippet testing "Description" b
for input in inputs:
	input[0\] = false
	input[1\] = false
endsnippet
